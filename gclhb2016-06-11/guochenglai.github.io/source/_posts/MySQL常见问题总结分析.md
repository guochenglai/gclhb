---
title: MySQL常见问题总结分析
toc: true
mathjax: true
date: 2016-06-02 09:56:10
categories: Mysql
tags: MySQL常见问题
description: 在我们日常的开发过程中，经常会遇到一些规则法则或者约定，在不知道原因的情况下，很多时候会抱怨DBA，为什么会有那么多的强制约定，明明我的业务这个字段需要为null，你却就是不让我为null，如果你不了解这里面的深层次原因，你肯定PK不过DBA，最后只能乖乖地修改自己的逻辑。下面这里常见的问题，是我在公司开发过程中收集总结的。里面有对问题原因的分析，希望能给大家提供帮助，解决困惑。
---
# limit和offset VS between和and
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在项目中经常遇到分页的操作，最常见的做法是使用limit和offset进行数据库的查询，这样在数据量比较小的时候没有什么问题，也显示不出来什么问题，但是在数据量比较大的时候，就会出现查询速度缓慢的情况，这个时候可替代的方案是使用between和and操作来替换之，具体的原因如下：

## limit和offset的执行过程
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当使用limit和offset分页查询指定下标的数据时，会进行计数也就是数出limit条记录，然后在将limit之后的offset条数据取出，所以limit和offset的执行过程中有一个遍历的操作，所以时间复杂度为o(n)，这也就解释了为什么 当数据量很大的时候你会发现越到最后分页操作越慢，原因就是越到最后遍历的数量越多造作越慢。

## between和and的执行过程
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分页操作的另外一种可替代方案是自己计算出分页的主键ID区间，然后利用between和and来进行查找，这样在查找就走的是主键索引按照B+树存储的主键索引的查找时间复杂度是log(n)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=red>分析了两种分页操作的时间复杂度可以看出，第一个时间复杂度是o(n)第二个时间复杂度是log(n)也就是数据量为1000的时候，两者的查询效率会相差10倍，如果数据量是一亿的时候，两者的查询效率就会相差一万倍。</font>  

# 为什么要求表的设计有自增ID
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在MySQL的innodb存储引擎中，DBA都要求每张表都必须显示声明一个自增的主键ID，这是什么原因呢？MySQL的innodb存储引擎在存储数据的时候是按照B+树存储的（也称为聚簇索引），而B+树的key就是自增Id，所以一般都会要求每一张表都会有一个自增ID，既然这样那如果一张表没有自增ID是不是就会出现异常或者存储的结构会发生变化呢，当然不会MySQL考虑到这种情况，当一张表没有自增ID的时候，会自动建立一个隐藏的自增ID，来实现上述的存储。

# 为啥DBA要求字段不能为null
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在每次进行sql申请的时候，dba都会要求显示的为每个字段添加“not nul default 'XXXXX' ”  这又是为什么呢？
  - null是占用空间的，在大家的固有思想里一般认为null是不占有空间的，但是事实是MySQL在存储null的时候会有一个位来标识这个字段是否为null
  - 也是最主要的原因MySQLnull值会影响索引的效率
  - 在使用MySQL分区的时候如果分区字段为null，那么对于不同的分区条件，就必须采用不同的特殊处理方式
```
    hash分区将null作为0特殊处理
    Range分区null作为分区最小值加入到最小的分区中
    list分区，必须指定null在哪个分区中 否则会报错
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到上面两点大家也就知道了null的危害，如果你的字段可以确保没有上述的危害，理论上是不需要not null 的约束，但是为啥dba会强制要求not null 我猜应该是两方面的考虑 1 很多人不知道以上两点 2 dba没法确认你的字段是否存在上述危害，所以干脆一刀切，所有的字段加非空约束，毕竟这样带来的好处比危害多很多。

# varchar(20) VS varchar(12)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在申请SQL的时候对于字符串类型，大家一般都会采用varchar类型，并且对长度进行估计，那么varchar(20)和varchar(12)到底有什么区别呢？
- varchar(20)中的20是20个字节，并且会有一个字节来存储末尾标识位，也就是说最多存储19个字节（最多19个拉丁字符）对于采用utf-8编码的汉字来说一个汉字一般占用2-3个字节，所有存储汉字的个数为6-9个（在MySQL5.1之后，varchar也是基于字符来表示的，所以varchar20就可以直接存储20个汉字）
- varchar(256)和4.1基本一致只是末尾标识位是两个字节
- 4.3 varchar(20)和varchar(12)的区别：

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先varchar(20)和varchar(12)对于同一个字符串在磁盘上存储的空间是相同，对于abc字符串而言就是占用四个字节。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然如上所说那么岂不是越到越好，这样既不占用磁盘空间又方便扩展可以兼容任何极端的情况。不是这样的。首先MySQL对一张表的varchar有一个长度的限制，其次在真正处理字符串的时候，是需要将字符串读取到内存的，而读取到内存是需要分配空间的，初始分配的空间的大小就是varchar定义的长度，所以，虽然两者在存储磁盘没有差别，但是在内存处理的时候第一个会占用更多的内存，所以我们在定义字符串的长度的时候，应该是根据业务情况选择一个合适的长度，

# int(4) VS int(10)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看了varchar中两者的区别那么，对于int类型而言这两种情况又有什么区别呢，是不是int(4)占用的空间比int(10)要小呢？实际的情况是int(4)和int(10)在磁盘的处理和占用的内存空间上面没有任何区别，他们唯一的区别是在客户端查看时候的区别，int(4)表示在客户端查看的时候，只显示4个字节的宽度，Int(10)显示的是10个字节的宽度    

# char的变与不变
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在常识中大家都任务char的长度是不变的，如果填充的字符不够会自动进行补零处理，但是是想这样一种情况
```
  char(20)  encoding=utf-8  可以存储20个中文字符
  char(20)  encoding=latin  可以存储20个英文字符
  第一个可能占用40个字节
  第二个可能占用20个字节
```
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有大家常说的char类型长度是不变的是指字符个数不变，其实占用的字节个数是变化的
